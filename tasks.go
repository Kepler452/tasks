/*
Package tasks is an easy to use in-process task scheduler for Go.

This package provides both recurring and one-time task execution. Tasks are run within their own goroutine which improves time accuracy for execution. This package also allows users to specify error handling though custom error functions.

Below is a simple example of starting the scheduler and registering a new task.

	// Start the Scheduler
	scheduler := tasks.New()
	defer scheduler.Stop()

	// Add a task
	id, err := scheduler.Add(&tasks.Task{
		Interval: time.Duration(30 * time.Second),
		TaskFunc: func() error {
			// Put your logic here
		}(),
		ErrFunc: func(err error) {
			// Put custom error handling here
		}(),
	})
	if err != nil {
		// Do Stuff
	}

For simplicity this task scheduler uses the time.Duration type to specify intervals. This allows for a simple interface and flexible control over when tasks are executed.

The below example shows scheduling a task to run only once 30 days from now.

	// Define time to execute
	t := time.Now().Add(30 * (24 * time.Hour))

	// Add a one time only task for 30 days from now
	id, err := scheduler.Add(&tasks.Task{
		Interval: time.Until(t),
		RunOnce:  true,
		TaskFunc: func() error {
			// Put your logic here
		}(),
		ErrFunc: func(err error) {
			// Put custom error handling here
		}(),
	})
	if err != nil {
		// Do Stuff
	}

*/
package tasks

import (
	"context"
	"fmt"
	"github.com/rs/xid"
	"sync"
	"time"
)

// Task contains the scheduled task details and control mechanisms. This struct is used during the creation of tasks. It allows users to control how and when tasks are executed.
type Task struct {
	// id is the Unique ID created for each task. This ID is generated by the Add() function.
	id string

	// Interval is the frequency that the task executes. Defining this at 30 seconds, will result in a task that runs every 30 seconds.
	//
	// The below are common examples to get started with.
	//
	//  // Every 30 seconds
	//  time.Duration(30 * time.Second)
	//  // Every 5 minutes
	//  time.Duration(5 * time.Minute)
	//  // Every 12 hours
	//  time.Duration(12 * time.Hour)
	//  // Every 30 days
	//  time.Duration(30 * (24 * time.Hour))
	//
	Interval time.Duration

	// RunOnce is used to set this task as a single execution task. By default, tasks will continue executing at the interval specified until deleted. With RunOnce enabled the first execution of the task will result in the task self deleting.
	RunOnce bool

	// TaskFunc is the user defined function to execute as part of this task.
	TaskFunc func() error

	// ErrFunc allows users to define a function that is called when tasks return an error. If ErrFunc is nil, errors from tasks will be ignored.
	ErrFunc func(error)

	// ticker is the internal task timer. This is stored here to provide control via main scheduler functions.
	ticker *time.Ticker

	// ctx is the internal context used to control task cancelation.
	ctx context.Context

	// cancel is used to cancel tasks gracefully. This will not interrupt a task function that has already been triggered.
	cancel context.CancelFunc
}

// Scheduler stores the internal task list and provides an interface for task management.
type Scheduler struct {
	sync.RWMutex

	// tasks is the internal task list used to store tasks that are currently scheduled.
	tasks map[string]*Task
}

// New will create a new scheduler instance that allows users to create and manage tasks.
func New() *Scheduler {
	s := &Scheduler{}
	s.tasks = make(map[string]*Task)
	return s
}

// Add will add a task to the task list and schedule it. Once added, tasks will wait the defined time interval and then execute. This means a task with a 15 second interval will be triggered 15 seconds after Add is complete. Not before or after (excluding typical machine time jitter).
//
//  // Add a task
//  id, err := scheduler.Add(&tasks.Task{
//  	Interval: time.Duration(30 * time.Second),
//  	TaskFunc: func() error {
//  		// Put your logic here
//  	}(),
//  	ErrFunc: func(err error) {
//  		// Put custom error handling here
//  	}(),
//  })
//  if err != nil {
//  	// Do stuff
//  }
//
func (schd *Scheduler) Add(t *Task) (string, error) {
	// Check if TaskFunc is nil before doing anything
	if t.TaskFunc == nil {
		return "", fmt.Errorf("task function cannot be nil")
	}

	// Ensure Interval is never 0, this would cause Ticker to panic
	if t.Interval <= time.Duration(0) {
		return "", fmt.Errorf("task interval must be defined")
	}
	t.ticker = time.NewTicker(t.Interval)

	// Create Context used to cancel downstream Goroutines
	t.ctx, t.cancel = context.WithCancel(context.Background())

	// Create ID, add to task list and start background task
	id := xid.New()
	schd.Lock()
	defer schd.Unlock()
	for {
		if _, ok := schd.tasks[id.String()]; ok {
			id = xid.New()
			continue
		}
		t.id = id.String()
		schd.tasks[t.id] = t
		go schd.execTask(t)
		return t.id, nil
	}
}

// Del will unschedule the specified task and remove it from the task list. Deletion will prevent future invocations of a task, but not interrupt a trigged task.
func (schd *Scheduler) Del(name string) {
	// Grab task from task list
	t, err := schd.Lookup(name)
	if err != nil {
		return
	}

	// Stop the task
	defer t.cancel()
	defer t.ticker.Stop()

	// Remove from task list
	schd.Lock()
	defer schd.Unlock()
	if _, ok := schd.tasks[name]; ok {
		delete(schd.tasks, name)
	}
	return
}

// Lookup will find the specified task from the internal task list using the task ID provided.
//
// The returned task should be treated as read-only, and not modified outside of this package. Doing so, may cause panics.
func (schd *Scheduler) Lookup(name string) (*Task, error) {
	schd.RLock()
	defer schd.RUnlock()
	t, ok := schd.tasks[name]
	if ok {
		return t, nil
	}
	return t, fmt.Errorf("could not find task within the task list")
}

// Tasks is used to return a copy of the internal tasks map.
//
// The returned task should be treated as read-only, and not modified outside of this package. Doing so, may cause panics.
func (schd *Scheduler) Tasks() map[string]*Task {
	schd.RLock()
	defer schd.RUnlock()
	return schd.tasks
}

// Stop is used to unschedule and delete all tasks owned by the scheduler instance.
func (schd *Scheduler) Stop() {
	tt := schd.Tasks()
	for n := range tt {
		schd.Del(n)
	}
}

// execTask is the underlying scheduler, it is used to trigger and execute tasks.
func (schd *Scheduler) execTask(t *Task) {
	for {
		select {
		case <-t.ticker.C:
			go func() {
				err := t.TaskFunc()
				if err != nil && t.ErrFunc != nil {
					go t.ErrFunc(err)
				}
				// If RunOnce is true, kill this task after one execution
				if t.RunOnce {
					defer schd.Del(t.id)
					return
				}
			}()
		case <-t.ctx.Done():
			return
		}
	}
}
