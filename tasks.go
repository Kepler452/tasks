/*
Package tasks provides an internal scheduler for Go.
*/
package tasks

import (
	"context"
	"fmt"
	"github.com/rs/xid"
	"sync"
	"time"
)

// Task contains the scheduled task details and control mechanisms.
type Task struct {
	// ID is the Unique ID created for each task. This ID is generated by the Scheduler Add() function.
	ID string

	// Interval is the time interval that this scheduled task will execute with. For example, if set with Time.Duration(30 * time.Second) this task will execute every 30 seconds.
	Interval time.Duration

	// TaskFunc is the user defined function to execute as part of this task.
	TaskFunc func() error

	// ErrFunc allows users to define a function to be called when TaskFunc calls return errors. If ErrFunc is nil, errors from tasks will be ignored.
	ErrFunc func(error)

	// ticker is the internal task ticker. This is stored here to provide control via main scheduler functions.
	ticker *time.Ticker

	// ctx is the internal context used to control task cancelation from users.
	ctx context.Context

	// cancel is used to cancel tasks gracefully.
	cancel context.CancelFunc
}

// Scheduler is used to store the internal task list. It also provides the interface for working with scheduled tasks.
type Scheduler struct {
	sync.RWMutex

	// tasks is the internal task list used to control what tasks are scheduled or not.
	tasks map[string]*Task
}

// New will create a new scheduler instance for users to create and manage in-process scheduled tasks.
func New() *Scheduler {
	s := &Scheduler{}
	s.tasks = make(map[string]*Task)
	return s
}

// Add will add a specified task to the task list. It also creates any internally used Task components.
func (schd *Scheduler) Add(t *Task) (string, error) {
	// Check if TaskFunc is nil before doing anything
	if t.TaskFunc == nil {
		return "", fmt.Errorf("task function cannot be nil")
	}

	// Ensure Interval is never 0, this would cause Ticker to panic
	if t.Interval <= time.Duration(0) {
		return "", fmt.Errorf("task interval must be defined")
	}
	t.ticker = time.NewTicker(t.Interval)

	// Create Context used to cancel downstream Goroutines
	t.ctx, t.cancel = context.WithCancel(context.Background())

	// Create ID, add to task list and start background task
	id := xid.New()
	schd.Lock()
	defer schd.Unlock()
	for {
		if _, ok := schd.tasks[id.String()]; ok {
			id = xid.New()
			continue
		}
		t.ID = id.String()
		schd.tasks[t.ID] = t
		go schd.execTask(t)
		return t.ID, nil
	}
}

// Del will remove a specific task from the internal task list.
func (schd *Scheduler) Del(name string) {
	// Grab task from task list
	t, err := schd.Lookup(name)
	if err != nil {
		return
	}

	// Stop the task
	defer t.cancel()
	defer t.ticker.Stop()

	// Remove from task list
	schd.Lock()
	defer schd.Unlock()
	if _, ok := schd.tasks[name]; ok {
		delete(schd.tasks, name)
	}
	return
}

// Lookup is used to lookup a specific task from the internal task list.
func (schd *Scheduler) Lookup(name string) (*Task, error) {
	schd.RLock()
	defer schd.RUnlock()
	t, ok := schd.tasks[name]
	if ok {
		return t, nil
	}
	return t, fmt.Errorf("could not find task within the task list")
}

// Tasks is used to return a copy of the internal tasks map. This function should only be used to read the contents of the internal schedule.
func (schd *Scheduler) Tasks() map[string]*Task {
	schd.RLock()
	defer schd.RUnlock()
	return schd.tasks
}

// Stop is used to stop all tasks within the task list.
func (schd *Scheduler) Stop() {
	tt := schd.Tasks()
	for n := range tt {
		schd.Del(n)
	}
}

// execTask is used to trigger and execute tasks.
func (schd *Scheduler) execTask(t *Task) {
	for {
		select {
		case <-t.ticker.C:
			go func() {
				err := t.TaskFunc()
				if err != nil && t.ErrFunc != nil {
					go t.ErrFunc(err)
				}
			}()
		case <-t.ctx.Done():
			return
		}
	}
}
